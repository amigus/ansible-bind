#!/usr/bin/env python3
"""
This script processes a list containing, hostnames (domains) or URLs, to generate a Response Policy Zone (RPZ) file.
The list can be one per line, or CSV or a JSON array containing and index/field that contains the hostname or URL.

Functions:
    generate_rpz(zone: str, input, output, passthrulist, length_limit) -> None:

    extract_using_jq(input, jq_expression: str):

    extract_field_from_csv(input, index: int):

    parse_url(url: str) -> str:

    parse_hostnames(input):

Usage:
    Unless -F and/or -f are provided, the script will read from stdin and write to stdout.
    If -Z is provided, the script will consider the input a list of hostnames or URLs and generate an RPZ.
    If -C is provided, the script will read a CSV file and extract the field at the specified index.
    If -J is provided, the script will filter JSON data using the provided jq expression.
    If -U is provided, the script will parse URLs to extract hostnames.

    Command-line options:
        -C index: Specifies the index of the field to extract from each row of the CSV input.
        -F output_file: Specifies the output file to write the results to. stdout is used if not provided.
        -f input_file: Specifies the input file to read data from. stdin is used if not provided.
        -J jq_expression: Specifies a jq expression to filter JSON data.
        -U: Indicates that the input is a list of URLs that should be parsed to extract hostnames.
        -H: Skips the first line (header) of the input file.
        -p: A file containing a list of hostnames to pass through the RPZ.
        -w: A file containing a list of hostnames to exclude from the RPZ.
        -Z zone: Specifies the DNS zone for which the RPZ is being generated.
        -L length: Specifies the maximum length of hostnames to include.

    Example:
        # Generate an RPZ file from a list of URLs in a the second column of a CSV file
        python genrpz.py -f input.csv -F output.rpz -Z example.com -C 1 -U
"""

import csv
from urllib.parse import urlparse
import os
from datetime import datetime
import sys
import getopt
import subprocess


def me() -> str:
    return os.path.basename(sys.argv[0])


def generate_rpz(zone: str, hostnames, output_file, passthrulist, length_limit) -> None:
    """
    Generates a Response Policy Zone (RPZ) file.

    Args:
        zone (str): The DNS zone for which the RPZ is being generated.
        hostnames (iterable): An iterable of hostnames to be included in the RPZ.
        output_file (file-like object): A file-like object to write the generated RPZ data to.
        passthrulist (list): A list of hostnames that should be passed through without modification.
        length_limit (int): The maximum length of hostnames to include. Use less than 1 for no limit.

    Writes:
        The function writes the RPZ data to the provided output file-like object. The RPZ file
        includes a TTL, SOA record, and NS record. Each hostname is processed and written as a
        CNAME record in the RPZ file.
    """
    output_file.write(f"$TTL 30\n")
    output_file.write(
        f"@ SOA rpz.{zone}. hostmaster.{zone}. {datetime.now():%y%m%d%H%M} 300 1800 604800 30\n"
    )
    output_file.write(
        f"\tNS localhost.\t; generated by {me()} on {datetime.now():%b %d, %Y}\n"
    )

    for hostname in set(hostnames):
        if length_limit < 1 or len(hostname) <= length_limit:
            if hostname and any(passthru in hostname for passthru in passthrulist):
                output_file.write(f"{hostname} CNAME rpz-passthru.\n")
            else:
                output_file.write(f"{hostname} CNAME .\n")


def extract_using_jq(input, jq_expression: str):
    """
    Extracts fields from a JSON input using a jq expression.

    Args:
        input (file-like object): A file-like object containing JSON data.
        jq_expression (str): A jq expression to filter the JSON data.

    Yields:
        str: Each line of the filtered JSON data.

    Raises:
        SystemExit: If the jq command fails, the function will print an error message and exit the program.
    """
    result = subprocess.run(
        ["jq", "-r", jq_expression], input=input.read(), text=True, capture_output=True
    )
    if result.returncode != 0:
        print(f"Error running jq: {result.stderr}", file=sys.stderr)
        sys.exit(1)
    for line in result.stdout.splitlines():
        yield line


def extract_field_from_csv(input, index: int):
    """
    Extracts a specific field from each row of a CSV file.

    Args:
        input (file-like object): The input CSV file.
        index (int): The index of the field to extract from each row.

    Yields:
        str: The value of the specified field from each row.
    """
    for row in csv.reader(input):
        yield row[index]


def parse_url(url: str) -> str:
    """
    Parses the given URL and returns the network location part (netloc).

    Args:
        url (str): The URL to be parsed.

    Returns:
        str: The network location part of the URL if valid, otherwise None.

    Raises:
        Exception: If an error occurs during URL parsing.

    Prints:
        Prints an error message to stderr if the URL is invalid or if an exception occurs.
    """
    try:
        parsed_url = urlparse(url)
        if parsed_url.scheme and parsed_url.netloc:
            return parsed_url.netloc
        else:
            print(f"Invalid URL: {url}", file=sys.stderr)
            return None
    except Exception as e:
        print(f"Error parsing URL {url}: {e}", file=sys.stderr)
        return None


def parse_hostnames(hostnames, whitelist):
    """
    Parses hostnames from an iterable of URLs and filters them based on a whitelist.

    Args:
        hostnames (iterable): An iterable containing URL strings.
        whitelist (list): A list of whitelisted URLs.

    Yields:
        str: Hostnames parsed from the URLs that are not in the whitelist.
    """
    for hostname in hostnames:
        if not any(excluded in hostname for excluded in whitelist):
            yield parse_url(hostname)


def main(argv):
    input_file = sys.stdin
    output_file = sys.stdout
    index = None
    jq_expression = None
    use_url_parsing = False
    zone = None
    whitelist = []
    passthrulist = []
    length_limit = -1

    try:
        opts, args = getopt.getopt(argv, "f:F:C:J:Up:w:Z:L:Hh?")
    except getopt.GetoptError:
        print(f"Usage: {me()} [-F <output>] [-f <input>] [ [-C <index>] | [-J <jq_expression>] ] [-U] [-Z <zone>] [-p <passthrulist_file>] [-w <whitelist_file>] [-L <length>] [-H] [-h?]")
        sys.exit(2)

    skip_header = False
    for opt, arg in opts:
        if opt == "-f":
            input_file = open(arg, "r")
        elif opt == "-F":
            output_file = open(arg, "w")
        elif opt == "-C":
            index = int(arg)
        elif opt == "-J":
            jq_expression = arg
        elif opt == "-U":
            use_url_parsing = True
        elif opt == "-Z":
            zone = arg
        elif opt == "-p":
            with open(arg, "r") as passthrulist_file:
                passthrulist = [line.strip() for line in passthrulist_file]
        elif opt == "-w":
            with open(arg, "r") as whitelist_file:
                whitelist = [line.strip() for line in whitelist_file]
        elif opt == "-L":
            length_limit = int(arg)
        elif opt == "-H":
            skip_header = True
        elif opt in ("-?", "-h"):
            print(f"Usage: {me()} [-F <output>] [-f <input>] [ [-C <index>] | [-J <jq_expression>] ] [-U] [-Z <zone>] [-p <passthrulist_file>] [-w <whitelist_file>] [-L <length>] [-H] [-h?]")
            sys.exit(1)

        if skip_header:
            next(input_file)

    if index is not None:
        hostnames = extract_field_from_csv(input_file, index)
    elif jq_expression is not None:
        hostnames = extract_using_jq(input_file, jq_expression)
    else:
        hostnames = (
            line.split("#", 1)[0].strip() for line in input_file
            if line.strip() and not line.strip().startswith("#")
        )

    if use_url_parsing:
        hostnames = parse_hostnames(hostnames, whitelist)

    if zone:
        generate_rpz(zone, hostnames, output_file, passthrulist, length_limit)
    else:
        for hostname in hostnames:
            if length_limit < 1 or len(hostname) <= length_limit:
                output_file.write(f"{hostname}\n")

    if input_file is not sys.stdin:
        input_file.close()
    if output_file is not sys.stdout:
        output_file.close()


if __name__ == "__main__":
    main(sys.argv[1:])
